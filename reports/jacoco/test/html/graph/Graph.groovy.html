<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">graph-dsl</a> &gt; <a href="index.source.html" class="el_package">graph</a> &gt; <span class="el_source">Graph.groovy</span></div><h1>Graph.groovy</h1><pre class="source lang-java linenums">package graph

import graph.plugin.Plugin
import graph.type.Type
import graph.type.undirected.GraphType
import groovy.transform.PackageScope
import static TraversalColor.*

/**
 * An implementation of a Graph. A {@link Vertex} is identified in this Graph using the vertex name property. A
 * {@link Edge} is identified by the names of the to vertices it connects.
 * &lt;p&gt;
 * {@link Vertex} and {@link Edge} objects are added using the vertex and edge methods. These methods will always create
 * objects if not present to reduce the code needed to express a graph and to ensure the integrity of the graph. There
 * are a few styles that may be used to express vertices and edges in this Graph. See the edge and vertex methods for
 * more details.
 * &lt;p&gt;
 * All graphs have a {@link graph.type.Type}. All Vertex, Edge, VertexSpec, and EdgeSpec objects must be created by
 * the Type. This is to ensure the {@link Graph} always has the behavior specified by the {@link graph.type.Type}.
 * &lt;p&gt;
 * The default behavior is that of an undirected graph. This is implemented by {@link GraphType}.
 */
class Graph implements VertexDsl, EdgeDsl, TraversalDsl {
    private Map&lt;Object, ? extends Vertex&gt; vertices = [:] as LinkedHashMap&lt;Object, ? extends Vertex&gt;
<span class="fc" id="L25">    private Set&lt;? extends Edge&gt; edges = [] as LinkedHashSet&lt;? extends Edge&gt;</span>
    private Type type
<span class="fc" id="L27">    private Set&lt;? extends Plugin&gt; plugins = [] as LinkedHashSet&lt;? extends Plugin&gt;</span>

    Graph() {
<span class="fc" id="L30">        type = new GraphType()</span>
<span class="fc" id="L31">        type.graph = this</span>
    }

    /**
     * static entry point to the dsl.
     * @param c closure to execute with graph as the delegate
     * @return the resulting graph
     */
    static Graph graph(@DelegatesTo(Graph) Closure c) {
<span class="fc" id="L40">        Graph graph = new Graph()</span>
<span class="fc" id="L41">        graph.with(c)</span>
<span class="pc" id="L42">        graph</span>
    }

    /**
     * returns the vertices as an unmodifiableMap.
     * @return vertices as an unmodifiableMap
     */
    Map&lt;Object, ? extends Vertex&gt; getVertices() {
<span class="pc" id="L50">        Collections.unmodifiableMap(vertices)</span>
    }

    Vertex getVertex(Object key) {
<span class="pc" id="L54">        vertices[key]</span>
    }

    /**
     * Removes the {@link Vertex} from vertices with the matching key. If the Vertex has adjacentEdges it cannot be
     * deleted an IllegalStateException will be thrown.
     * @param key key of {@link Vertex} to delete from this graph
     * @throws IllegalStateException if key vertex has adjacentEdges.
     * @see {@link Graph#adjacentEdges(Object)}
     */
    void delete(Object key) {
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (adjacentEdges(key)) {</span>
<span class="fc" id="L66">            throw new IllegalStateException(</span>
                    &quot;Cannot delete $key. There are edges that connect to it. Try deleting those first.&quot;
            )
        }
<span class="fc" id="L70">        vertices.remove(key)</span>
    }

    /**
     * returns the edges as an unmodifiable set
     * @return edges as an unmodifiable set
     */
    Set&lt;? extends Edge&gt; getEdges() {
<span class="pc" id="L78">        Collections.unmodifiableSet(edges)</span>
    }

    /**
     * Adds an edge object directly.
     * @param edge to add
     * @return true if add was successful.
     */
    @PackageScope
    boolean addEdge(Edge edge) {
<span class="pc" id="L88">        edges.add(edge)</span>
    }

    /**
     * Replaces edges with results of running edges.collect(closure)
     * @param closure to run on each edge
     */
    void replaceEdges(Closure closure) {
<span class="fc" id="L96">        List replace = edges.collect(closure)</span>
<span class="fc" id="L97">        edges.clear()</span>
<span class="fc" id="L98">        edges.addAll(replace)</span>
    }

    /**
     * Replaces set of edges used by Graph with the given set.
     * @param set to replace set of edges
     */
    void replaceEdgesSet(Set&lt;? extends Edge&gt; set) {
<span class="fc bfc" id="L106" title="All 4 branches covered.">        if (!set.empty) {</span>
<span class="fc" id="L107">            throw new IllegalArgumentException('set must be empty.')</span>
        }
<span class="fc" id="L109">        set.addAll(edges)</span>
<span class="fc" id="L110">        edges = set</span>
    }

    /**
     * Replaces entries in vertices {@link Map}. The closure should return map entries for each entry passed in.
     * @param closure returns replaced entries.
     */
    void replaceVertices(Closure closure) {
<span class="fc" id="L118">        Map&lt;String, ? extends Vertex&gt; replace = vertices.collectEntries(closure) as Map&lt;String, Vertex&gt;</span>
<span class="fc" id="L119">        vertices.clear()</span>
<span class="fc" id="L120">        vertices.putAll(replace)</span>
    }

    /**
     * Replaces vertices {@link Map}. The original entries are added to the new {@link Map} object.
     * @param map
     */
    void replaceVerticesMap(Map&lt;String, ? extends Vertex&gt; map) {
<span class="fc bfc" id="L128" title="All 4 branches covered.">        if (!map.isEmpty()) {</span>
<span class="fc" id="L129">            throw new IllegalArgumentException('map must be empty.')</span>
        }
<span class="fc" id="L131">        map.putAll(vertices)</span>
<span class="fc" id="L132">        vertices = map</span>
    }

    /**
     * Removes an {@link Edge} from edges If a type changes the definition of an edge, for example to
     * {@link graph.type.directed.DirectedEdge}, this method will still work as expected. It will remove the edge where
     * edge.one == one and edge.two == two. Keep in mind, in the case of the base {@link Edge} object edge.one can also
     * equal two and edge.two can also equal one.
     * @param one key of first vertex
     * @param two key of second vertex
     */
    void deleteEdge(Object one, Object two) {
<span class="fc" id="L144">        edges.remove(type.newEdge(one: one, two: two))</span>
    }

    /**
     * Converts this Graph to the {@link Type} passed in.
     * @param typeClass type to convert Graph into
     */
    void type(Class typeClass) {
<span class="fc bfc" id="L152" title="All 4 branches covered.">        if (!Type.isAssignableFrom(typeClass)) {</span>
<span class="fc" id="L153">            throw new IllegalArgumentException(&quot;$typeClass.name does not implement Type&quot;)</span>
        }
<span class="fc" id="L155">        type = (Type) typeClass.newInstance()</span>
<span class="fc" id="L156">        type.graph = this</span>
<span class="fc" id="L157">        type.convert()</span>
    }

    /**
     * Searches for a properties file on the classpath using &quot;/META-INF/graph-types/${typeName}.properties&quot;. A
     * property 'implementation-class' is used to find the {@link Type} class. The class is used to convert this graph.
     * @param typeName name of type to convert graph
     */
    void type(String typeName) {
<span class="fc" id="L166">        Properties properties = new Properties()</span>
<span class="fc" id="L167">        properties.load(getClass().getResourceAsStream(&quot;/META-INF/graph-types/${typeName}.properties&quot;))</span>
<span class="fc" id="L168">        type(this.class.classLoader.loadClass((String) properties.'implementation-class'))</span>
    }

    /**
     * Applies a {@link Plugin} to this Graph.
     * @param pluginClass plugin to apply
     */
    void plugin(Class pluginClass) {
<span class="fc bfc" id="L176" title="All 4 branches covered.">        if (!Plugin.isAssignableFrom(pluginClass)) {</span>
<span class="fc" id="L177">            throw new IllegalArgumentException(&quot;$pluginClass.name does not implement Plugin&quot;)</span>
        }
<span class="fc" id="L179">        Plugin plugin = (Plugin) pluginClass.newInstance()</span>
<span class="fc" id="L180">        plugin.graph = this</span>
<span class="fc" id="L181">        plugins.add plugin</span>
    }

    /**
     * Searches for a properties file on the classpath using &quot;/META-INF/graph-plugins/${pluginName}.properties&quot;. A
     * property 'implementation-class' is used to find the {@link Plugin} class. The plugin class is applied to this
     * graph.
     * @param pluginName name of plugin to apply
     */
    void plugin(String pluginName) {
<span class="fc" id="L191">        Properties properties = new Properties()</span>
<span class="fc" id="L192">        properties.load(getClass().getResourceAsStream(&quot;/META-INF/graph-plugins/${pluginName}.properties&quot;))</span>
<span class="fc" id="L193">        plugin(this.class.classLoader.loadClass((String) properties.'implementation-class'))</span>
    }

    /**
     * Returns the type of this Graph.
     * @return the type of this graph
     */
    Type getType() {
<span class="pc" id="L201">        type</span>
    }

    /**
     * Adds a vertex object directly. For internal use to create copies of a Graph.
     * @param vertex
     * @return true if add was successful.
     */
    @PackageScope
    boolean addVertex(Vertex vertex) {
<span class="pc" id="L211">        vertices[vertex.key] = vertex</span>
    }

    /**
     * Replaces the key of a {@link Vertex}. All edges connecting the {@link Vertex} are updated with the new key.
     * @param key of original vertex
     * @param newKey for updated vertex
     */
    void changeKey(Object key, Object newKey) {
<span class="fc bfc" id="L220" title="All 10 branches covered.">        if (!key || !newKey) {</span>
<span class="fc" id="L221">            throw new IllegalArgumentException('key or newKey is null or empty.')</span>
        }
<span class="fc" id="L223">        Vertex vertex = vertex(key)</span>
<span class="fc" id="L224">        vertices.remove(vertex.key)</span>
<span class="fc" id="L225">        vertex.key = newKey</span>
<span class="fc" id="L226">        vertices[(Object) vertex.key] = vertex</span>
<span class="fc" id="L227">        adjacentEdges(key).each {</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">            if (it.one == key) {</span>
<span class="fc" id="L229">                it.one = newKey</span>
            }
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (it.two == key) {</span>
<span class="pc" id="L232">                it.two = newKey</span>
            }
        }
    }

    /**
     * Creates or updates a {@link Vertex} in this graph. The map contains configuration described in
     * {@link #vertex(Map)}. The closure contains configuration described in {@link #vertex(Object, Closure)}.
     * @param spec specification for vertex
     * @return The resulting {@link Vertex}.
     */
    Vertex vertex(ConfigSpec spec) {
<span class="pc" id="L244">        type.newVertexSpec(spec.map, spec.closure).apply()</span>
    }

    /**
     * Applies spec to this graph.
     * @param spec the specification for an {@link Edge}
     * @return the resulting {@link Edge}.
     */
    Edge edge(ConfigSpec spec) {
<span class="pc" id="L253">        type.newEdgeSpec(spec.map, spec.closure).apply()</span>
    }

    /**
     * Returns the first unvisited vertex key in vertices.
     *
     * @param colors map of vertex key and TraversalColor entries.
     * @return the first unvisited vertex key in vertices.
     */
    Object getUnvisitedVertexKey(Map colors) {
<span class="pc" id="L263">        vertices.find { k, v -&gt;</span>
<span class="pc bfc" id="L264" title="All 4 branches covered.">            colors[(k)] != BLACK &amp;&amp; colors[(k)] != GREY</span>
        }?.key
    }

    /**
     * returns the first unvisited child key with a parent matching key.
     *
     * @param key the key of the parent vertex to start searching from
     * @param colors a map of vertex key and TraversalColor entries.
     * @return the first unvisited child key with a parent matching key.
     */
    Object getUnvisitedChildKey(Object key, Map&lt;Object, TraversalColor&gt; colors) {
<span class="fc" id="L276">        Edge edge = traverseEdges(key).findAll {</span>
<span class="pc" id="L277">            it.one != it.two</span>
        }.find {
<span class="fc bfc" id="L279" title="All 2 branches covered.">            Object childKey = key == it.one ? it.two : it.one</span>
<span class="fc" id="L280">            TraversalColor color = colors[childKey]</span>
<span class="pc bfc" id="L281" title="All 4 branches covered.">            color != GREY &amp;&amp; color != BLACK</span>
        }

<span class="fc bfc" id="L284" title="All 4 branches covered.">        if (!edge) {</span>
<span class="fc" id="L285">            return null</span>
        }
<span class="pc bfc" id="L287" title="All 2 branches covered.">        key == edge.one ? edge.two : edge.one</span>
    }

    /**
     * Finds adjacent edges for vertex with key.
     * @param key
     * @return set of adjacent edges.
     */
    Set&lt;? extends Edge&gt; adjacentEdges(Object key) {
<span class="pc" id="L296">        edges.findAll { Edge edge -&gt;</span>
<span class="pc bfc" id="L297" title="All 4 branches covered.">            key == edge.one || key == edge.two</span>
        }
    }

    /**
     * If the missing method is in the assigned {@link Type} the method will be called on type. Otherwise a
     * {@link ConfigSpec} is created and returned.
     * @param name
     * @param args
     * @return result of calling method on Type or a ConfigSpec
     */
    @SuppressWarnings('Instanceof')
    @SuppressWarnings('NoDef')
    def methodMissing(String name, args) {
<span class="fc" id="L311">        MetaMethod method = type.metaClass.getMetaMethod(name, args)</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (method != null) {</span>
<span class="fc" id="L313">            return method.invoke(type, args)</span>
        }

<span class="fc" id="L316">        def list = plugins.collect { plugin -&gt;</span>
<span class="fc" id="L317">            MetaMethod m = plugin.metaClass.getMetaMethod(name, args)</span>
<span class="fc bfc" id="L318" title="All 2 branches covered.">            if (m) {</span>
<span class="fc" id="L319">                return [plugin, m]</span>
            }
<span class="pc" id="L321">            null</span>
        }.find { list -&gt;
<span class="pc" id="L323">            list</span>
        }

<span class="fc bfc" id="L326" title="All 2 branches covered.">        if (list != null) {</span>
<span class="fc" id="L327">            return list[1].invoke(list[0], args)</span>
        }
<span class="pc" id="L329">        throw new MissingMethodException(name, Graph, args)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>