<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Graph.groovy</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">graph-dsl</a> &gt; <a href="index.source.html" class="el_package">graph</a> &gt; <span class="el_source">Graph.groovy</span></div><h1>Graph.groovy</h1><pre class="source lang-java linenums">package graph

import groovy.transform.PackageScope

/**
 * An implementation of a Graph. A {@link Vertex} is identified in this Graph using the vertex name property. A
 * {@link Edge} is identified by the names of the to vertices it connects.
 * &lt;p&gt;
 * {@link Vertex} and {@link Edge} objects are added using the vertex and edge methods. These methods will always create
 * objects if not present to reduce the code needed to express a graph and to ensure the integrity of the graph. There
 * are a few styles that may be used to express vertices and edges in this Graph. See the edge and vertex methods for
 * more details.
 * &lt;p&gt;
 * The default behavior is that of an undirected graph. There can only be one {@link Edge} between any two vertices.
 * When traversing a graph an {@link Edge} is adjacent to a {@link Vertex} if it's one or two property equals the name
 * of the {@link Vertex}.
 * &lt;p&gt;
 * Plugins may be applied to this graph to change its behavior and the behavior of the vertices and edges within this
 * graph. For more information on plugins see {@link Plugin}.
 */
class Graph {
    private final Map&lt;String, ? extends Vertex&gt; vertices = [:] as LinkedHashMap&lt;String, ? extends Vertex&gt;
<span class="fc" id="L23">    private Set&lt;? extends Edge&gt; edges = [] as LinkedHashSet&lt;? extends Edge&gt;</span>
<span class="fc" id="L24">    private final Set&lt;? extends Plugin&gt; plugins = [] as LinkedHashSet&lt;? extends Plugin&gt;</span>
    @PackageScope
<span class="fc" id="L26">    EdgeFactory edgeFactory = new UnDirectedEdgeFactory()</span>
    @PackageScope
<span class="fc" id="L28">    VertexFactory vertexFactory = new DefaultVertexFactory()</span>

    /**
     * An enum defining traversal status. A value from this enum can be returned
     * from one of the closures passed to search methods changing the behavior of a traversal.
     */
    enum Traversal {
        /**
         * stops the current traversal. Useful in search when a vertex is found to end the traversal early.
         */
        STOP
    }

    /**
     * Defines the color for a vertex when traversing.
     */
    enum TraversalColor {
        /**
         * an undiscovered vertex
         */
        WHITE,
        /**
         * a discovered vertex that still needs work
         */
        GREY,
        /**
         * a vertex that the algorithm is done with
         */
         BLACK
    }

    /**
     * static entry point for creating a graph within a groovy script.
     * @param c
     * @return
     */
    static Graph graph(Closure c) {
<span class="fc" id="L65">        Graph graph = new Graph()</span>
<span class="fc" id="L66">        graph.with(c)</span>
<span class="pc" id="L67">        graph</span>
    }

    /**
     * returns the vertices as an unmodifiableMap
     * @return
     */
    Map&lt;String, ? extends Vertex&gt; getVertices() {
<span class="pc" id="L75">        Collections.unmodifiableMap(vertices)</span>
    }

    /**
     * returns the edges as an unmodifiable set
     * @return
     */
    Set&lt;? extends Edge&gt; getEdges() {
<span class="pc" id="L83">        Collections.unmodifiableSet(edges)</span>
    }

    /**
     * returns plugins as an unmodifiable set
     * @return
     */
    Set&lt;? extends Plugin&gt; getPlugins() {
<span class="pc" id="L91">        Collections.unmodifiableSet(plugins)</span>
    }

    /**
     * Creates and applies a {@link Plugin} to this graph.
     * @param pluginClass - the {@link Plugin} to create and apply to this graph.
     * @return
     */
    void apply(Class pluginClass) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (plugins.contains(pluginClass)) {</span>
<span class="fc" id="L101">            throw new IllegalArgumentException(&quot;$pluginClass.name is already applied.&quot;)</span>
        }
<span class="fc bfc" id="L103" title="All 4 branches covered.">        if (!pluginClass.interfaces.contains(Plugin)) {</span>
<span class="fc" id="L104">            throw new IllegalArgumentException(&quot;$pluginClass.name does not implement Plugin&quot;)</span>
        }
<span class="fc" id="L106">        plugins &lt;&lt; pluginClass</span>
<span class="fc" id="L107">        Plugin plugin = pluginClass.newInstance()</span>
<span class="fc" id="L108">        plugin.apply(this)</span>
    }

    /**
     * Adds a vertex object directly. For internal use to create copies of a Graph.
     * @param vertex
     * @return true if add was successful.
     */
    @PackageScope
    boolean addVertex(Vertex vertex) {
<span class="pc" id="L118">        vertices[vertex.name] = vertex</span>
    }

    /**
     * Finds the {@link Vertex} with the given name or creates a new one.
     * @param name - the name of the {@link Vertex} to find or create.
     * @return the resulting {@link Vertex}
     * @throws {@link IllegalArgumentException} When name is null or empty.
     */
    Vertex vertex(String name) {
<span class="pc" id="L128">        vertex(new VertexSpec(name:name))</span>
    }

    /**
     * Finds or creates all vertices returning them in a Set.
     * @param names
     * @return
     */
    Set&lt;Vertex&gt; vertex(String... names) {
<span class="pc" id="L137">        names.collect { name -&gt;</span>
<span class="pc" id="L138">            vertex(name)</span>
        } as Set&lt;Vertex&gt;
    }

    /**
     * Creates or updates a {@link Vertex} in this graph. The map must contain configuration described in
     * {@link VertexSpec#newInstance(Map)}.
     * @param map
     * @return the resulting {@link Vertex}
     */
    Vertex vertex(Map&lt;String, ?&gt; map) {
<span class="fc" id="L149">        VertexSpec spec = VertexSpec.newInstance(map)</span>
<span class="pc" id="L150">        vertex(spec)</span>
    }

    /**
     * Creates or updates a {@link Vertex} in this graph with the given name. The configuration given by the closure is
     * delegated to a {@link VertexSpecCodeRunner} See {@link VertexSpecCodeRunner#runCode(Closure } for details on how
     * it modifies this graph and the { @ link Vertex } .
     * @param name
     * @param closure
     * @return
     */
    Vertex vertex(String name, Closure closure) {
<span class="fc" id="L162">        VertexSpec spec = new VertexSpec(name:name)</span>
<span class="fc" id="L163">        spec.runnerCode closure</span>
<span class="pc" id="L164">        vertex(spec)</span>
    }

    /**
     * Renames a {@link Vertex}. All edges connecting the {@link Vertex} are updated with the new name.
     * @param name
     * @param newName
     */
    void rename(String name, String newName) {
<span class="fc bfc" id="L173" title="All 4 branches covered.">        if (!newName) {</span>
<span class="fc" id="L174">            throw new IllegalArgumentException('newName is null or empty.')</span>
        }
<span class="fc" id="L176">        Vertex vertex = vertex(name)</span>
<span class="fc" id="L177">        vertices.remove(vertex.name)</span>
<span class="fc" id="L178">        vertex.name = newName</span>
<span class="fc" id="L179">        vertices[vertex.name] = vertex</span>
<span class="fc" id="L180">        adjacentEdges(name).each {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            if (it.one == name) {</span>
<span class="fc" id="L182">                it.one = newName</span>
            }
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (it.two == name) {</span>
<span class="pc" id="L185">                it.two = newName</span>
            }
        }
    }

    /**
     * Creates or updates a {@link Vertex} in this graph with the given name. The map must contain configuration
     * described in {@link VertexSpec#newInstance(Map)}.
     * @param name
     * @param map
     * @return
     */
    Vertex vertex(String name, Map&lt;String, ?&gt; map) {
<span class="fc" id="L198">        VertexSpec spec = new VertexSpec(name:name)</span>
<span class="fc" id="L199">        spec = spec.overlay(VertexSpec.newInstance(map))</span>
<span class="pc" id="L200">        vertex(spec)</span>
    }

    /**
     * Creates or updates a {@link Vertex} in this graph. The configuration given by the closure is delegated to a
     * {@link VertexSpecCodeRunner} See {@link VertexSpecCodeRunner#runCode(Closure)} for details on how it modifies
     * this graph and the {@link Vertex}.
     * @param map -
     * @param closure -
     * @return the resulting vertex
     */
    Vertex vertex(Map&lt;String, ?&gt; map, Closure closure) {
<span class="fc" id="L212">        VertexSpec spec = VertexSpec.newInstance(map)</span>
<span class="fc" id="L213">        spec.runnerCode closure</span>
<span class="pc" id="L214">        vertex(spec)</span>
    }

    /**
     * Creates or updates a {@link Vertex} in this graph.
     * @param name
     * @param map
     * @param closure
     * @return
     */
    Vertex vertex(String name, Map&lt;String, ?&gt; map, Closure closure) {
<span class="fc" id="L225">        VertexSpec spec = new VertexSpec(name:name)</span>
<span class="fc" id="L226">        spec = spec.overlay(VertexSpec.newInstance(map))</span>
<span class="fc" id="L227">        spec.runnerCode closure</span>
<span class="pc" id="L228">        vertex(spec)</span>
    }

    /**
     * Creates or updates a {@link Vertex} in this graph. The {@link VertexSpec} is applied.
     * @param spec
     * @return
     */
    Vertex vertex(VertexSpec spec) {
<span class="pc" id="L237">        spec.apply(this)</span>
    }

    /**
     * Adds an edge object directly.
     * @param edge
     * @return true if add was successful.
     */
    @PackageScope
    boolean addEdge(Edge edge) {
<span class="pc" id="L247">        edges &lt;&lt; edge</span>
    }

    /**
     * Creates or finds an edge between two vertices. The vertices are checked using {#vertex(String... names)}. If the
     * edge already exists it is returned.
     * @param one - the name of the first {@link Vertex}
     * @param two - the name of the second {@link Vertex}
     * @return the resulting edge
     */
    Edge edge(String one, String two) {
<span class="fc" id="L258">        vertex(one, two)</span>
<span class="fc" id="L259">        Edge e = edgeFactory.newEdge(one, two)</span>
<span class="pc bfc" id="L260" title="All 2 branches covered.">        Edge edge = edges.find { it == e } ?: e</span>
<span class="fc" id="L261">        edges &lt;&lt; edge</span>
<span class="pc" id="L262">        edge</span>
    }

    /**
     * Creates or updates a {@link Edge} in this graph. See {@link EdgeSpec#applyToGraphAndEdge(Graph, Edge)} for
     * details on how this graph and the {@link Edge} are modified.
     * @param closure - delegates to {@link EdgeSpec}
     * @return the resulting {@link Edge}
     */
    Edge edge(@DelegatesTo(EdgeSpec) Closure closure) {
<span class="fc" id="L272">        EdgeSpec spec = EdgeSpec.newInstance(this, closure)</span>
<span class="fc" id="L273">        Edge edge = edge(spec.one, spec.two)</span>
<span class="fc" id="L274">        spec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L275">        edge</span>
    }

    /**
     * Creates or updates a {@link Edge} in this graph. The map must contain configuration described in
     * {@link EdgeSpec#newInstance(Map)}.
     * @param map
     * @return the resulting {@link Edge}
     */
    Edge edge(Map&lt;String, ?&gt; map) {
<span class="fc" id="L285">        EdgeSpec spec = EdgeSpec.newInstance(map)</span>
<span class="fc" id="L286">        Edge edge = edge(spec.one, spec.two)</span>
<span class="fc" id="L287">        spec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L288">        edge</span>
    }

    /**
     * Creates or updtes a {@link Edge} in this graph with the given one and two. The configuration given by the closure
     * is delegated to an {@link EdgeSpec}. See {@link EdgeSpec#applyToGraphAndEdge(Graph, Edge)} for details on how it
     * modifies this graph and the {@link Edge}.
     * @param one
     * @param two
     * @param closure
     * @return
     */
    Edge edge(String one, String two, @DelegatesTo(EdgeSpec) Closure closure) {
<span class="fc" id="L301">        EdgeSpec spec = EdgeSpec.newInstance(this, closure)</span>
<span class="fc" id="L302">        Edge edge = edge(one, two)</span>
<span class="fc" id="L303">        spec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L304">        edge</span>
    }

    /**
     * Creates or updates a {@link Edge} in this graph with the given one and two. The map must contain configuration
     * described in {@link EdgeSpec#newInstance(Map)}.
     * @param one
     * @param two
     * @param map
     * @return
     */
    Edge edge(String one, String two, Map&lt;String, ?&gt; map) {
<span class="fc" id="L316">        EdgeSpec spec = EdgeSpec.newInstance(map)</span>
<span class="fc" id="L317">        Edge edge = edge(one, two)</span>
<span class="fc" id="L318">        spec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L319">        edge</span>
    }

    /**
     * Creates or updates a {@link Edge} in this graph. This methods creates two {@link EdgeSpec} objects from the
     * map and closure. The map is applied before the clsoure using {@link EdgeSpec#applyToGraphAndEdge(Graph, Edge)}.
     * @param map
     * @param closure
     * @return
     */
    Edge edge(Map&lt;String, ?&gt; map, @DelegatesTo(EdgeSpec) Closure closure) {
<span class="fc" id="L330">        EdgeSpec mapSpec = EdgeSpec.newInstance(map)</span>
<span class="fc" id="L331">        EdgeSpec closureSpec = EdgeSpec.newInstance(this, closure)</span>
<span class="fc" id="L332">        Edge edge = edge(mapSpec.one, mapSpec.two)</span>
<span class="fc" id="L333">        mapSpec.applyToGraphAndEdge(this, edge)</span>
<span class="fc" id="L334">        closureSpec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L335">        edge</span>
    }

    /**
     * Creates or updates a {@link Edge} in this graph with the given one and two. This methods creates two
     * {@link EdgeSpec} objects from the map and closure. The map is applied before the clsoure using
     * {@link EdgeSpec#applyToGraphAndEdge(Graph, Edge)}.
     * @param one
     * @param two
     * @param map
     * @param closure
     * @return
     */
    Edge edge(String one, String two, Map&lt;String, ?&gt; map, @DelegatesTo(EdgeSpec) Closure closure) {
<span class="fc" id="L349">        EdgeSpec mapSpec = EdgeSpec.newInstance(map)</span>
<span class="fc" id="L350">        EdgeSpec closureSpec = EdgeSpec.newInstance(this, closure)</span>
<span class="fc" id="L351">        Edge edge = edge(one, two)</span>
<span class="fc" id="L352">        mapSpec.applyToGraphAndEdge(this, edge)</span>
<span class="fc" id="L353">        closureSpec.applyToGraphAndEdge(this, edge)</span>
<span class="pc" id="L354">        edge</span>
    }

    /**
     * Returns the first unvisited vertex name in vertices.
     *
     * @param colors a map of vertex name entries with the value of the TraversalColor
     * @return the first unvisited vertex name in the vertices.
     */
    String getUnvisitedVertexName(colors) {
<span class="pc" id="L364">        vertices.find { k, v -&gt;</span>
<span class="pc bfc" id="L365" title="All 4 branches covered.">            colors[(k)] != TraversalColor.BLACK &amp;&amp; colors[k] != TraversalColor.GREY</span>
        }?.key
    }

    /**
     * returns the name of first unvisited child vertex with a parent matching parentName.
     *
     * @param colors a map of vertex name entries with the value of the TraversalColor
     * @param parentName the name of the parent vertex to start searching from
     * @return the name of the first unvisited child vertex
     */
    @SuppressWarnings('BooleanMethodReturnsNull')
    String getUnvisitedChildName(Map&lt;String, TraversalColor&gt; colors, String parentName) {
<span class="fc" id="L378">        Edge edge = traverseEdges(parentName).findAll {</span>
<span class="pc" id="L379">            it.one != it.two</span>
        }.find {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            String childName = parentName == it.one ? it.two : it.one</span>
<span class="fc" id="L382">            TraversalColor color = colors[childName]</span>
<span class="pc bpc" id="L383" title="1 of 6 branches missed.">            !(color == TraversalColor.GREY || color == TraversalColor.BLACK)</span>
        }

<span class="fc bfc" id="L386" title="All 4 branches covered.">        if (!edge) {</span>
<span class="fc" id="L387">            return null</span>
        }
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        parentName == edge.one ? edge.two : edge.one</span>
    }

    /**
     * Finds adjacent edges for vertex with name.
     * @param name
     * @return set of adjacent edges.
     */
    Set&lt;? extends Edge&gt; adjacentEdges(String name) {
<span class="pc" id="L398">        edges.findAll {</span>
<span class="pc bfc" id="L399" title="All 4 branches covered.">            name == it.one || name == it.two</span>
        }
    }

    /**
     * Returns edges from vertex with name that should be traversed.
     * @param name
     * @return
     */
    Set&lt;? extends Edge&gt; traverseEdges(String name) {
<span class="pc" id="L409">        adjacentEdges(name)</span>
    }

    /**
     * creates and returns a color map in the form of
     * name : color. name is the vertex
     * name and TraversalColor.WHITE is the
     * color.
     * @return
     */
    Map makeColorMap() {
<span class="pc" id="L420">        vertices.collectEntries { name, vertex -&gt;</span>
<span class="pc" id="L421">            [(name):TraversalColor.WHITE]</span>
        }
    }

    /**
     * configures a depth first traversal with the given closure using
     * depthFirstTraversalSpec().
     *
     * Once the spec is configured traversal(graph.&amp;depthFirstTraversalConnected, spec) is called.
     *
     * @param specClosure
     * @return
     */
    Traversal depthFirstTraversal(Closure specClosure) {
<span class="fc" id="L435">        DepthFirstTraversalSpec spec = depthFirstTraversalSpec(specClosure)</span>
<span class="pc" id="L436">        traversal(this.&amp;depthFirstTraversalConnected, spec)</span>
    }

    /**
     * creates a DepthFirstTraversalSpec from the provided closure.
     *
     * defaults will be configured with the setupSpec method.
     *
     * @param specClosure is a closure that has a new DepthFirstTraversalSpec
     * as a delegate. Modify the DepthFirstTraversalSpec in this closure to
     * change the behavior of the depth first traversal.
     * @return
     */
    DepthFirstTraversalSpec depthFirstTraversalSpec(Closure specClosure) {
<span class="fc" id="L450">        DepthFirstTraversalSpec spec = new DepthFirstTraversalSpec()</span>
<span class="fc" id="L451">        specClosure.delegate = spec</span>
<span class="fc" id="L452">        specClosure()</span>
<span class="fc" id="L453">        setupSpec(spec)</span>
<span class="pc" id="L454">        spec</span>
    }

    /**
     * Configures defaults for a TraversalSpec. When colors and root are not set
     * This method will generate defaults.
     *
     * if colors is not defined in the spec it defaults to the result of
     * makeColorMap()
     *
     * if root is not defined in the spec it defaults to the result of
     * getUnvisitedVertexName(spec.colors)
     * @param spec the traversal spec to configure with defaults.
     */
    void setupSpec(TraversalSpec spec) {
<span class="fc bfc" id="L469" title="All 2 branches covered.">        spec.colors = spec.colors ?: makeColorMap()</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">        spec.root = spec.root ?: getUnvisitedVertexName(spec.colors)</span>
    }

    /**
     * Creates a BreadthFirstTraversalSpec with the given closure.
     *
     * defaults will be configured with the setupSpec method.
     *
     * @param specClosure is a closure that has a new BreadthFirstTraversalSpec
     * as a delegate. Modify the BreadthFirstTraversalSpec in this closure to
     * change the behavior of the breadth first traversal.
     * @return
     */
    BreadthFirstTraversalSpec breadthFirstTraversalSpec(Closure specClosure) {
<span class="fc" id="L484">        BreadthFirstTraversalSpec spec = new BreadthFirstTraversalSpec()</span>
<span class="fc" id="L485">        specClosure.delegate = spec</span>
<span class="fc" id="L486">        specClosure()</span>
<span class="fc" id="L487">        setupSpec(spec)</span>
<span class="pc" id="L488">        spec</span>
    }

    /**
     * Performs a traversal with the given traversalConnected method and TraversalSpec on all
     * components of the graph. This method calls traversalConnected on spec.root
     * and continues to call traversalConnected until all vertices are colored black.
     * To stop the traversal early the spec can return Traversal.STOP in any of the
     * traversal closures.
     * @param traversalConnected - one of the traversalConnected methods in this graph
     * @param spec
     * @return null or a Traversal value
     */
    Traversal traversal(traversalConnected, spec) {
<span class="fc" id="L502">        String name = spec.root</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">        while (name) {</span>
<span class="fc" id="L504">            Traversal traversal = traversalConnected(name, spec)</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">            if (traversal == Traversal.STOP) {</span>
<span class="fc" id="L506">                return Traversal.STOP</span>
            }
<span class="fc" id="L508">            name = getUnvisitedVertexName(spec.colors)</span>
        }
<span class="pc" id="L510">        null</span>
    }

    /**
     * Performs a depth first traversal on a connected component of the graph starting
     * at the vertex identified by root. The behavior of the traversal is determined by
     * spec.colors, spec.preorder, and spec.postorder.
     *
     * Traversal.STOP - It is possible to stop the traversal early by returning this value
     * in preorder and postorder.
     * @param root the root of the vertex to start at
     * @param spec the DepthFirstTraversalSpec
     * @return null or a Traversal value
     */
    Traversal depthFirstTraversalConnected(String root, DepthFirstTraversalSpec spec) {
<span class="fc bfc" id="L525" title="All 6 branches covered.">        if (spec.preorder &amp;&amp; spec.preorder(vertices[root]) == Traversal.STOP) {</span>
<span class="fc" id="L526">            spec.colors[root] = TraversalColor.GREY</span>
<span class="fc" id="L527">            return Traversal.STOP</span>
        }
<span class="fc" id="L529">        spec.colors[root] = TraversalColor.GREY</span>

<span class="fc" id="L531">        Set&lt;Edge&gt; adjacentEdges = traverseEdges(root)</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (int index = 0; index &lt; adjacentEdges.size(); index++) { //cannot stop and each() call on adjacentEdges</span>
<span class="fc" id="L533">            Edge edge = adjacentEdges[index]</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            String connectedName = root == edge.one ? edge.two : edge.one</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            if (spec.classifyEdge &amp;&amp; spec.classifyEdge(edge, root, connectedName,</span>
<span class="fc bfc" id="L536" title="All 4 branches covered.">                    spec.colors[connectedName]) == Traversal.STOP) {</span>
<span class="fc" id="L537">                return Traversal.STOP</span>
            }
<span class="fc bfc" id="L539" title="All 2 branches covered.">            if (spec.colors[connectedName] == TraversalColor.WHITE) {</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">                if (Traversal.STOP == depthFirstTraversalConnected(connectedName, spec)) {</span>
<span class="fc" id="L541">                    return Traversal.STOP</span>
                }
            }

        }

<span class="fc bfc" id="L547" title="All 6 branches covered.">        if (spec.postorder &amp;&amp; spec.postorder(vertices[root]) == Traversal.STOP) {</span>
<span class="fc" id="L548">            spec.colors[root] = TraversalColor.BLACK</span>
<span class="fc" id="L549">            return Traversal.STOP</span>
        }
<span class="fc" id="L551">        spec.colors[root] = TraversalColor.BLACK</span>
<span class="pc" id="L552">        null</span>
    }

    /**
     * executes closure on each {@link Vertex} in breadth first order. See {@link #breadthFirstTraversal} for details.
     * @param closure
     */
    void eachBfs(Closure closure) {
<span class="fc" id="L560">        eachBfs(null, closure)</span>
    }

    /**
     * executes closure on each {@link Vertex} in breadth first order starting at the given root {@link Vertex}. See
     * {@link #breadthFirstTraversal} for details.
     * @param root
     * @param closure
     */
    void eachBfs(String root, Closure closure) {
<span class="fc" id="L570">        breadthFirstTraversal {</span>
<span class="fc" id="L571">            delegate.root = root</span>
<span class="pc" id="L572">            visit { vertex -&gt;</span>
<span class="fc" id="L573">                closure(vertex)</span>
<span class="pc" id="L574">                null</span>
            }
        }
    }

    /**
     * Executes closure on each {@link Vertex} in breadth first order. If the closure returns true the {@link Vertex} is
     * returned.
     * @param closure closure to execute on each {@link Vertex}
     * @return first {@link Vertex} where closure returns true
     */
    Vertex findBfs(Closure closure) {
<span class="pc" id="L586">        findBfs(null, closure)</span>
    }

    /**
     * Executes closure on each {@link Vertex} in breadth first order starting at root. If the closure returns true the
     * {@link Vertex} is returned.
     * @param root where to start breadth first traversal
     * @param closure closure to execute on each {@link Vertex}
     * @return first {@link Vertex} where closure returns true
     */
    Vertex findBfs(String root, Closure closure) {
<span class="fc" id="L597">        Vertex result = null</span>
<span class="fc" id="L598">        breadthFirstTraversal {</span>
<span class="fc" id="L599">            delegate.root = root</span>
<span class="pc" id="L600">            visit { vertex -&gt;</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                if (closure(vertex)) {</span>
<span class="fc" id="L602">                    result = vertex</span>
<span class="pc" id="L603">                    return Traversal.STOP</span>
                }
            }
        }
<span class="pc" id="L607">        result</span>
    }

    /**
     * Executes closure on each vertex in breadth first order. object is the initial value passed to the closure. Each
     * returned value from the closure is passed to the next call.
     * @param object
     * @param closure
     * @return object returned from the final call to closure.
     */
    Object injectBfs(Object object, Closure closure) {
<span class="pc" id="L618">        injectBfs(null, object, closure)</span>
    }

    /**
     * Executes closure on each vertex in breadth first order starting at root. object is the initial value passed to
     * the closure. Each returned value from the closure is passed to the next call.
     * @param root
     * @param object
     * @param closure
     * @return object returned from the final call to closure.
     */
    Object injectBfs(String root, Object object, Closure closure) {
<span class="fc" id="L630">        Object result = object</span>
<span class="fc" id="L631">        breadthFirstTraversal {</span>
<span class="fc" id="L632">            delegate.root = root</span>
<span class="pc" id="L633">            visit { vertex -&gt;</span>
<span class="pc" id="L634">                result = closure(result, vertex)</span>
            }
        }
<span class="pc" id="L637">        result</span>
    }

    /**
     * Runs closure on each vertex in breadth first order. The vertices where closure returns true are returned.
     * @param closure to run on each vertex
     * @return the vertices where closure returns true
     */
    List&lt;? extends Vertex&gt; findAllBfs(Closure closure) {
<span class="pc" id="L646">        findAllBfs(null, closure)</span>
    }

    /**
     * Runs closure on each vertex in breadth first order starting at root. The vertices where closure returns true are
     * returned.
     * @param root the vertex to start from
     * @param closure to run on each vertex
     * @return the vertices where closure returns true
     */
    List&lt;? extends Vertex&gt; findAllBfs(String root, Closure closure) {
<span class="pc" id="L657">        (List&lt;? extends Vertex&gt;) injectBfs(root, []) { result, vertex -&gt;</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">            if (closure(vertex)) {</span>
<span class="fc" id="L659">                result &lt;&lt; vertex</span>
            }
<span class="pc" id="L661">            result</span>
        }
    }

    /**
     * Runs closure on each vertex in breadth first order collecting the result.
     * @param closure to run on each vertex
     * @return the results from closure
     */
    List&lt;? extends Vertex&gt; collectBfs(Closure closure) {
<span class="pc" id="L671">        collectBfs(null, closure)</span>
    }

    /**
     * Runs closure on each vertex in breadth first order, starting at root, collecting the result.
     * @param root vertex to start at
     * @param closure to run on each vertex
     * @return the results from closure
     */
    List&lt;? extends Vertex&gt; collectBfs(String root, Closure closure) {
<span class="pc" id="L681">        (List&lt;? extends Vertex&gt;) injectBfs(root, []) { result, vertex -&gt;</span>
<span class="pc" id="L682">            result &lt;&lt; closure(vertex)</span>
        }
    }

    /**
     * configures a breadth first traversal with the given closure using
     * breadthFirstTraversalSpec().
     *
     * Once the spec is configured traversal(this.&amp;breadthFirstTraversalConnected, spec) is called.
     *
     * @param specClosure
     * @return
     */
    Traversal breadthFirstTraversal(Closure specClosure) {
<span class="fc" id="L696">        BreadthFirstTraversalSpec spec = breadthFirstTraversalSpec(specClosure)</span>
<span class="pc" id="L697">        traversal(this.&amp;breadthFirstTraversalConnected, spec)</span>
    }

    /**
     * Performs a breadth first traversal on a connected component of the graph starting
     * at the vertex identified by root. The behavior of the traversal is determined by
     * spec.colors and spec.visit.
     *
     * Traversal.STOP - It is possible to stop the traversal early by returning this value
     * in visit.
     * @param root the root of the vertex to start at
     * @param spec the BreadthFirstTraversalSpec
     * @return null or a Traversal value
     */
    Traversal breadthFirstTraversalConnected(String root, BreadthFirstTraversalSpec spec) {
<span class="fc bfc" id="L712" title="All 4 branches covered.">        if (!vertices[root]) {</span>
<span class="fc" id="L713">            throw new IllegalArgumentException(&quot;Could not find $root in graph&quot;)</span>
        }
<span class="fc" id="L715">        def traversal = spec.visit(vertices[root])</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (traversal == Traversal.STOP) {</span>
<span class="fc" id="L717">            spec.colors[root] = TraversalColor.GREY</span>
<span class="fc" id="L718">            return traversal</span>
        }
<span class="fc" id="L720">        spec.colors[root] = TraversalColor.GREY</span>
<span class="fc" id="L721">        Queue&lt;String&gt; queue = [] as Queue&lt;String&gt;</span>
<span class="fc" id="L722">        queue &lt;&lt; root</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        while (queue.size() != 0) {</span>
<span class="fc" id="L724">            String current = queue.poll()</span>
<span class="fc" id="L725">            Set&lt;Edge&gt; adjacentEdges = traverseEdges(current)</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">            for (int i = 0; i &lt; adjacentEdges.size(); i++) {</span>
<span class="fc" id="L727">                Edge edge = adjacentEdges[i]</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                String connected = current == edge.one ? edge.two : edge.one</span>
<span class="fc bfc" id="L729" title="All 2 branches covered.">                if (spec.colors[connected] == TraversalColor.WHITE) {</span>
<span class="fc" id="L730">                    traversal = spec.visit(vertices[connected])</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                    if (traversal == Traversal.STOP) {</span>
<span class="fc" id="L732">                        spec.colors[connected] = TraversalColor.GREY</span>
<span class="fc" id="L733">                        return traversal</span>
                    }
<span class="fc" id="L735">                    spec.colors[connected] = TraversalColor.GREY</span>
<span class="fc" id="L736">                    queue &lt;&lt; connected</span>
                }
            }
<span class="fc" id="L739">            spec.colors[current] = TraversalColor.BLACK</span>
        }
<span class="pc" id="L741">        null</span>
    }

    /**
     * Classifies edges in a depthFirstTraversal returning the results.
     * @param action passed into EdgeClassification.addEdge
     * @return the resulting EdgeClassification
     */
    EdgeClassification classifyEdges(Closure action) {
<span class="fc" id="L750">        EdgeClassification ec = new EdgeClassification()</span>
<span class="fc" id="L751">        depthFirstTraversal {</span>
<span class="pc" id="L752">            classifyEdge { Edge edge, String from, String to, TraversalColor toColor -&gt;</span>
<span class="pc" id="L753">                ec.addEdge(this, edge, from, to, toColor, action)</span>
            }
        }
<span class="pc" id="L756">        ec</span>
    }

    /**
     * Creates a {@link VertexSpec}
     * @param name
     * @return a {@link VertexSpec} with name set to the property name.
     */
    @SuppressWarnings('NoDef')
    def propertyMissing(String name) {
<span class="pc" id="L766">        VertexSpec.newInstance(name:name)</span>
    }

    /**
     * Creates a {@link VertexSpec}. The result is similar to calling {@link VertexSpec#newInstance(Map)}
     * &lt;pre&gt;
     *     VertexSpec.newInstance([name:name + args[0])
     * &lt;/pre&gt;
     * @param name
     * @param args
     * @return a {@link VertexSpec}
     */
    @SuppressWarnings('Instanceof')
    @SuppressWarnings('NoDef')
    def methodMissing(String name, args) {
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">        if(name == 'vertex') {</span>
<span class="nc" id="L782">            throw new IllegalArgumentException(&quot;Confusing name 'vertex' for spec.&quot;)</span>
        }
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (args.size() == 0) {</span>
<span class="fc" id="L785">            return this.&quot;$name&quot;</span>
        }

<span class="fc bfc" id="L788" title="All 6 branches covered.">        if (args.size() == 1 &amp;&amp; args[0] instanceof Map) {</span>
<span class="fc" id="L789">            VertexSpec spec = this.&quot;$name&quot;</span>
<span class="fc" id="L790">            return spec.overlay(VertexSpec.newInstance(args[0]))</span>
        }

<span class="pc bpc" id="L793" title="1 of 6 branches missed.">        if (args.size() == 1 &amp;&amp; args[0] instanceof Closure) {</span>
<span class="fc" id="L794">            VertexSpec spec = this.&quot;$name&quot;</span>
<span class="fc" id="L795">            spec.runnerCode args[0]</span>
<span class="fc" id="L796">            return spec</span>
        }

<span class="pc bpc" id="L799" title="5 of 10 branches missed.">        if (args.size() == 2 &amp;&amp; args[0] instanceof Map &amp;&amp; args[1] instanceof Closure) {</span>
<span class="fc" id="L800">            VertexSpec spec = this.&quot;$name&quot;</span>
<span class="fc" id="L801">            spec = spec.overlay(VertexSpec.newInstance(args[0]))</span>
<span class="fc" id="L802">            spec.runnerCode args[1]</span>
<span class="pc" id="L803">            return spec</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>